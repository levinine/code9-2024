Assignments:
Split the ‘concert-monolith’ monolithic application into microservices.

Steps:
-Step1:
	-Extract the ‘ticket’ logic from the application into a separate microservice called ‘ticket-service’. 
	After this step, the application and exposed endpoints should work the same.
-Step2:
	-After step one is done, extract the ‘customer’ logic from the application into a separate micro service called ’customer-service’
	-Rename the monolithic application (what is left of it) to ‘concert-service’, since the remaining code should be responsible only for the ‘concert’ logic.

Hints:

-The outcome of this excercise is that the interface of the applicatio and its logic remains the same.

-To create a new microservice, feel free to use the official Spring-boot initializer: https://start.spring.io/
 The service should be set up with: Java21, Maven, Jar,	Spring-boot 3.2.5.
 Dependencies that should be added with the initializer are: Spring web, Jpa, H2 database and Lombok.


-The following dependencies will need to exist in monolithic application (or later the service that calls other services):

<dependency>
	<groupId>org.springframework.cloud</groupId>
	<artifactId>spring-cloud-starter-openfeign</artifactId>
</dependency>

<dependencyManagement>
	<dependencies>
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-dependencies</artifactId>
			<version>${spring-cloud.version}</version>
			<type>pom</type>
			<scope>import</scope>
		</dependency>
	</dependencies>
</dependencyManagement>

Spring-cloud.version can be f.e. ‘2023.0.1’

-The application.yaml that exists in the monolith needs to be added to the new services as well. Changes will be required for the service name, port and the H2 database url.

-The services must run on different ports, otherwise they will clash and won’t work.

-The data.sql (with different data) will have to exist in all 3 services, because now each service is responsible for a different h2 database.

-@EnableFeignClients and @FeignClients(url*, name) annotations will need to be used, where the url* represents the address of the service that is being called.

-Entities that are connected to other entities with objects and JPA annotations (f.e. @ManyToOne) will need to be changed to scalar IDs because now each service has its own database.
